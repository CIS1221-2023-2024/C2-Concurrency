Concurrency Python

arrayGenerator.py

#Generate and return a list of random integers

Replace return [random.randint(0, 10000) for _ in range(array_size)] with 

return random.sample(range(10001), array_size) 

#A list containing array_size elements is generated, and the size of every element is between 0 and 10000 both inclusive.

This is because the values generated by the random.sample function will be unique, and the code will be shorter and easier to understand. If one were to use the random.randint function to generate the values and make sure that they are unique it would take a lot of iterations and it would take longer for the code to execute if the array contains a lot of elements.

bubbleSortFunction.py

To improve the code a Boolean variable can be added to check if there was a swap in the pass. If there was no swap the program exits as it would already be sorted. We can also keep track of the last index which was swapped and put in the correct position so that we avoid any extra comparisons and do all the necessary arrangements for the for loop. This would look like this:

![image](https://github.com/CIS1221-2023-2024/C2-Concurrency/assets/150594221/dc24825f-3bfe-4029-9750-c8c80e9f8007)

Concurrency Java

ArrayGenerator.java

When creating the ArrayList the size of the ArrayList can be initialized as since it is a dynamic data structure if its size is specified before hand this reduces the amount of times it has to resize the array. This can be done by changing the line: List<Integer> elements = new ArrayList<>(); to            List<Integer> elements = new ArrayList<>(size);

BubbleSortFunction.java

Just like the bubble sort function using python a Boolean variable to check if there was a swap can be added so that if the list is sorted the program exists immediately. In the inner for loop where variable j is used as a counter for the range for which it needs to loop can be changed to array.size()-i since in this way the loop wonâ€™t need to iterate over the elements which have already been sorted. All of this can be implemented by changing the code to look like this:

![image](https://github.com/CIS1221-2023-2024/C2-Concurrency/assets/150594221/f28b3929-318f-4044-95cb-57c7dec024d2)

MergedArray.java

To add all the remaining elements after one of the arrays is empty as all elements have been merged the program is looping and always adding every element one by one. Rather than looping, the addAll function can be used which makes the code shorter and uses the same concept. 8 lines of code become only 2 lines of code. This can be implemented in the following way:

This is how it currently is:

![image](https://github.com/CIS1221-2023-2024/C2-Concurrency/assets/150594221/a3e761fc-5ce1-45af-9059-54f673370599)

This is how it can be implemented:

![image](https://github.com/CIS1221-2023-2024/C2-Concurrency/assets/150594221/32861a97-2eb0-4a6d-b1e9-0766c381a292)

Just like before the size of the list of the mergedArray can also be specified beforehand. So the line: 

List<Integer> mergedArray = new ArrayList<>(); now becomes 			                       

List<Integer> mergedArray = new ArrayList<>(size1 + size2);

Main.java

When the user is prompted to input the size of the array it should be checked if the size inputted by the user is valid. To do this to the readSizeFromConsole() method a do while loop needs to be implemented. This is how it can be implemented:

![image](https://github.com/CIS1221-2023-2024/C2-Concurrency/assets/150594221/72612336-f3aa-4951-980d-aafb8f9f2466)
